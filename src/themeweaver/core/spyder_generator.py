"""
Spyder Python file generator module for ThemeWeaver.

This module handles the generation of Spyder-compatible Python files:
- colorsystem.py with color class definitions
- palette.py with palette class definitions and semantic mappings
"""

import logging
from pathlib import Path
from typing import Any, Dict, Optional

from themeweaver.core.palette import create_palettes
from themeweaver.core.palette_comments import get_comment_for_attribute
from themeweaver.core.yaml_loader import (
    load_color_mappings_from_yaml,
    load_colors_from_yaml,
    load_semantic_mappings_from_yaml,
)

_logger = logging.getLogger(__name__)


class SpyderFileGenerator:
    """Generates Spyder-compatible Python files from ThemeWeaver themes."""

    def generate_files(
        self,
        theme_name: str,
        theme_metadata: Dict[str, Any],
        export_dir: Path,
        themes_dir: Optional[Path] = None,
    ) -> None:
        """Generate all Spyder-compatible Python files.

        Args:
            theme_name: Name of the theme
            theme_metadata: Theme metadata from theme.yaml
            export_dir: Export directory
            themes_dir: Directory where themes are stored. If None, uses default.
        """
        _logger.info("🐍 Generating Spyder Python files...")

        # Generate colorsystem.py
        colorsystem_path = export_dir / "colorsystem.py"
        self.generate_colorsystem_file(
            theme_name, theme_metadata, colorsystem_path, themes_dir=themes_dir
        )

        # Generate palette.py
        palette_path = export_dir / "palette.py"
        self.generate_palette_file(
            theme_name, theme_metadata, palette_path, themes_dir=themes_dir
        )

        # Generate __init__.py
        self.generate_theme_init_file(
            theme_name, theme_metadata, export_dir, themes_dir=themes_dir
        )

        _logger.info(
            "📄 Generated: %s, %s, %s",
            colorsystem_path.name,
            palette_path.name,
            "__init__.py",
        )

    def generate_colorsystem_file(
        self,
        theme_name: str,
        theme_metadata: Dict[str, Any],
        output_path: Path,
        themes_dir: Optional[Path] = None,
    ) -> None:
        """Generate colorsystem.py file compatible with Spyder's expectations."""
        # Load color definitions
        colors_data = load_colors_from_yaml(theme_name, themes_dir=themes_dir)
        color_mappings = load_color_mappings_from_yaml(
            theme_name, themes_dir=themes_dir
        )

        # Build the template components
        header = f"""# -*- coding: utf-8 -*-
#
# Generated by ThemeWeaver
# Theme: {theme_metadata.get("display_name", theme_name.title())}
# Description: {theme_metadata.get("description", "")}
# Author: {theme_metadata.get("author", "Unknown")}
# Version: {theme_metadata.get("version", "1.0.0")}

"""
        docstring = f'''"""
Color palettes used by the {theme_metadata.get("display_name", theme_name.title())} theme in Spyder.
"""

'''

        # Generate color class definitions
        color_classes = []

        for class_name, palette_name in color_mappings.items():
            if palette_name in colors_data:
                colors = colors_data[palette_name]

                # Generate class definition
                class_def = f"class {class_name}:\n"
                for color_key, color_value in colors.items():
                    # Clean up any malformed hex values (like "##FFFFFF")
                    if isinstance(color_value, str) and color_value.startswith("##"):
                        color_value = color_value[1:]  # Remove extra #
                    class_def += f"    {color_key} = '{color_value}'\n"

                color_classes.append(class_def)

        # Combine all components
        content = header + docstring + "\n\n".join(color_classes)

        # Write file
        output_path.write_text(content, encoding="utf-8")

    def generate_palette_file(
        self,
        theme_name: str,
        theme_metadata: Dict[str, Any],
        output_path: Path,
        themes_dir: Optional[Path] = None,
    ) -> None:
        """Generate palette.py file compatible with Spyder's expectations."""
        # Build the template components
        theme_display_name = theme_metadata.get("display_name", theme_name.title())

        header = f"""# -*- coding: utf-8 -*-
#
# Generated by ThemeWeaver
# Theme: {theme_display_name}
# Description: {theme_metadata.get("description", "")}
# Author: {theme_metadata.get("author", "Unknown")}
# Version: {theme_metadata.get("version", "1.0.0")}

"""

        docstring = f'''"""
Palettes for {theme_display_name} theme used in Spyder.
"""

'''

        # Load color mappings and semantic mappings
        color_mappings = load_color_mappings_from_yaml(
            theme_name, themes_dir=themes_dir
        )
        semantic_mappings = load_semantic_mappings_from_yaml(
            theme_name, themes_dir=themes_dir
        )
        color_imports = ", ".join(color_mappings.keys())

        imports = f"""# Standard library imports
from collections import OrderedDict

# Local imports
from .colorsystem import {color_imports}

"""

        base_palette_class = """# =============================================================================
# ---- Base Palette class
# =============================================================================

class Palette(object):
    \"\"\"Base palette mixin.\"\"\"

    ID = None

    # Color
    COLOR_BACKGROUND_1 = ''
    COLOR_BACKGROUND_2 = ''
    COLOR_BACKGROUND_3 = ''
    COLOR_BACKGROUND_4 = ''
    COLOR_BACKGROUND_5 = ''
    COLOR_BACKGROUND_6 = ''

    COLOR_TEXT_1 = ''
    COLOR_TEXT_2 = ''
    COLOR_TEXT_3 = ''
    COLOR_TEXT_4 = ''

    COLOR_ACCENT_1 = ''
    COLOR_ACCENT_2 = ''
    COLOR_ACCENT_3 = ''
    COLOR_ACCENT_4 = ''
    COLOR_ACCENT_5 = ''

    COLOR_DISABLED = ''

    OPACITY_TOOLTIP = 0

    # Size
    SIZE_BORDER_RADIUS = '4px'

    # Borders
    BORDER_1 = "1px solid $COLOR_BACKGROUND_1"
    BORDER_2 = "1px solid $COLOR_BACKGROUND_4"
    BORDER_3 = "1px solid $COLOR_BACKGROUND_6"

    BORDER_SELECTION_3 = "1px solid $COLOR_ACCENT_3"
    BORDER_SELECTION_2 = "1px solid $COLOR_ACCENT_2"
    BORDER_SELECTION_1 = "1px solid $COLOR_ACCENT_1"

    # Example of additional widget specific variables
    W_STATUS_BAR_BACKGROUND_COLOR = COLOR_ACCENT_1

    # Paths
    PATH_RESOURCES = "':/qss_icons'"

    @classmethod
    def to_dict(cls, colors_only=False):
        \"\"\"Convert variables to dictionary.\"\"\"
        order = [
            'ID',
            'COLOR_BACKGROUND_6',
            'COLOR_BACKGROUND_5',
            'COLOR_BACKGROUND_4',
            'COLOR_BACKGROUND_2',
            'COLOR_BACKGROUND_3',
            'COLOR_BACKGROUND_1',
            'COLOR_TEXT_1',
            'COLOR_TEXT_2',
            'COLOR_TEXT_3',
            'COLOR_TEXT_4',
            'COLOR_ACCENT_1',
            'COLOR_ACCENT_2',
            'COLOR_ACCENT_3',
            'COLOR_ACCENT_4',
            'COLOR_ACCENT_5',
            'COLOR_DISABLED',
            'OPACITY_TOOLTIP',
            'SIZE_BORDER_RADIUS',
            'BORDER_1',
            'BORDER_2',
            'BORDER_3',
            'BORDER_SELECTION_3',
            'BORDER_SELECTION_2',
            'BORDER_SELECTION_1',
            'W_STATUS_BAR_BACKGROUND_COLOR',
            'PATH_RESOURCES',
        ]
        dic = OrderedDict()
        for var in order:
            value = getattr(cls, var)

            if var == 'ID':
                value = "'{}'".format(value)

            if colors_only:
                if not var.startswith('COLOR'):
                    value = None

            if value:
                dic[var] = value

        return dic

    @classmethod
    def color_palette(cls):
        \"\"\"Return the ordered colored palette dictionary.\"\"\"
        return cls.to_dict(colors_only=True)

    @staticmethod
    def from_dict(class_values, class_name="FromDictPalette"):
        \"\"\"Return palette class definition from dictionary.\"\"\"
        return type(class_name, (Palette, ), class_values)

"""

        palette_header = f"""# =============================================================================
# ---- {theme_display_name} palettes
# =============================================================================

"""

        # Load palettes to generate class definitions
        palettes = create_palettes(theme_name, themes_dir=themes_dir)
        palette_classes = []

        # Common palette attributes that all variants should have
        common_attributes = """
    # Border radius
    SIZE_BORDER_RADIUS = '4px'

    # Borders
    BORDER_1 = "1px solid $COLOR_BACKGROUND_1"
    BORDER_2 = "1px solid $COLOR_BACKGROUND_4"
    BORDER_3 = "1px solid $COLOR_BACKGROUND_6"

    BORDER_SELECTION_3 = "1px solid $COLOR_ACCENT_3"
    BORDER_SELECTION_2 = "1px solid $COLOR_ACCENT_2"
    BORDER_SELECTION_1 = "1px solid $COLOR_ACCENT_1"

    # Widget specific variables
    W_STATUS_BAR_BACKGROUND_COLOR = COLOR_ACCENT_1

    # Paths
    PATH_RESOURCES = "':/qss_icons'"
"""

        # Helper function to generate a palette class for a variant
        def generate_palette_class(variant):
            class_name = f"SpyderPalette{variant.title()}"
            variant_attrs = []
            variant_semantic = semantic_mappings.get(variant, {})

            # Add ID attribute first
            variant_attrs.append(f'    ID = "{variant}"')

            # Group attributes by their comments
            comment_groups = {}
            for attr_name, color_ref in variant_semantic.items():
                comment = get_comment_for_attribute(attr_name)
                if comment not in comment_groups:
                    comment_groups[comment] = []

                # Format the attribute line
                if isinstance(color_ref, (int, float)):
                    attr_line = f"    {attr_name} = {color_ref}"
                elif isinstance(color_ref, tuple) and len(color_ref) == 3:
                    # Handle tuples with formatting (color, bold, italic)
                    color_ref_str, bold, italic = color_ref
                    attr_line = f"    {attr_name} = ({color_ref_str}, {bold}, {italic})"
                else:
                    attr_line = f"    {attr_name} = {color_ref}"
                comment_groups[comment].append(attr_line)

            # Build the class content with comments
            for comment, attrs in comment_groups.items():
                if comment:
                    variant_attrs.append(f"    {comment}")
                variant_attrs.extend(attrs)

            # Generate the class content
            return f"""class {class_name}(Palette):
    \"\"\"{variant.title()} palette for {theme_metadata.get("display_name", theme_name)}.\"\"\"\n
{chr(10).join(variant_attrs)}
{common_attributes}"""

        # Generate palette classes for each supported variant
        if palettes.has_dark:
            palette_classes.append(generate_palette_class("dark"))

        if palettes.has_light:
            palette_classes.append(generate_palette_class("light"))

        # Combine all components
        content = (
            header
            + docstring
            + imports
            + base_palette_class
            + palette_header
            + "\n\n".join(palette_classes)
        )

        # Write file
        output_path.write_text(content, encoding="utf-8")

    def generate_theme_init_file(
        self,
        theme_name: str,
        theme_metadata: Dict[str, Any],
        export_dir: Path,
        themes_dir: Optional[Path] = None,
    ) -> None:
        """Generate __init__.py for theme package."""

        # Determine which palette classes exist
        palettes = create_palettes(theme_name, themes_dir=themes_dir)
        has_dark = palettes.has_dark
        has_light = palettes.has_light

        # Generate imports based on available palettes
        if has_dark and has_light:
            imports = "from .palette import SpyderPaletteDark, SpyderPaletteLight"
            exports = "['SpyderPaletteDark', 'SpyderPaletteLight', 'THEME_ID']"
        elif has_dark:
            imports = "from .palette import SpyderPaletteDark"
            exports = "['SpyderPaletteDark', 'THEME_ID']"
        else:
            imports = "from .palette import SpyderPaletteLight"
            exports = "['SpyderPaletteLight', 'THEME_ID']"

        # Generate content
        content = f'''# -*- coding: utf-8 -*-
"""
Theme: {theme_metadata.get("display_name", theme_name.title())}
Author: {theme_metadata.get("author", "Unknown")}
"""

{imports}

THEME_ID = "{theme_name}"

__all__ = {exports}
'''

        # Write file
        init_path = export_dir / "__init__.py"
        init_path.write_text(content, encoding="utf-8")
